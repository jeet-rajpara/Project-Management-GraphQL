package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.46

import (
	"context"
	"fmt"
	"project_management/api/dataloaders"
	req "project_management/api/models"
	"project_management/api/repository"
	validate "project_management/api/validation"
	er "project_management/errors"
	"project_management/graph/model"
	"project_management/utils"
)

// Creator is the resolver for the creator field.
func (r *getProjectDetailResolver) Creator(ctx context.Context, obj *model.GetProjectDetail) (*model.User, error) {
	creator, err := dataloaders.CtxLoaders(ctx).UserByID.Load(obj.CreatorID)
	if err != nil {
		return nil, er.InternalServerError
	}
	return creator, nil
}

// ScreenShot is the resolver for the screenShot field.
func (r *getProjectDetailResolver) ScreenShot(ctx context.Context, obj *model.GetProjectDetail) ([]*model.Screenshot, error) {
	screenshots, err := dataloaders.CtxLoaders(ctx).Screenshots.Load(obj.ID)
	if err != nil {
		return nil, er.InternalServerError
	}
	return screenshots, nil
}

// ProjectMember is the resolver for the projectMember field.
func (r *getProjectDetailResolver) ProjectMember(ctx context.Context, obj *model.GetProjectDetail) ([]*model.ProjectMember, error) {
	projectMembers, err := dataloaders.CtxLoaders(ctx).ProjectMemberByProjectID.Load(obj.ID)
	if err != nil {
		return nil, er.InternalServerError
	}
	return projectMembers, nil
}

// CreateProject is the resolver for the createProject field.
func (r *mutationResolver) CreateProject(ctx context.Context, input req.NewProject) (string, error) {
	// Validate the input
	if err := validate.ValidateInput(input); err != nil {
		return "", err
	}

	var newProject req.NewProject
	newProject.Name = input.Name
	newProject.Description = input.Description
	newProject.ProfilePhoto = input.ProfilePhoto
	newProject.CategoryID = input.CategoryID
	newProject.Rooms = input.Rooms
	newProject.Floors = input.Floors
	newProject.Price = input.Price
	newProject.ScreenShot = input.ScreenShot
	// newProject.UserID = input.UserID
	message, err := repository.CreateProject(ctx, newProject)

	return message, err
}

// DeleteProject is the resolver for the deleteProject field.
func (r *mutationResolver) DeleteProject(ctx context.Context, projectID string) (*string, error) {

	if !validate.IsInteger(projectID) {
		return nil, er.WrongIDError
	}

	message, err := repository.DeleteProject(ctx, projectID)
	return &message, err
}

// UpdateProject is the resolver for the updateProject field.
func (r *mutationResolver) UpdateProject(ctx context.Context, input req.UpdateProject) (*model.Project, error) {
	// Validate the input
	if err := validate.ValidateInput(input); err != nil {
		return &model.Project{}, err
	}
	updatedProject, err := repository.UpdateProject(ctx, input)
	return &updatedProject, err
}

// AddScreenshot is the resolver for the addScreenshot field.
func (r *mutationResolver) AddScreenshot(ctx context.Context, input []*req.NewScreenshot) (*string, error) {
	var messages []string
	var count int
	for _, screenshot := range input {
		var newScreenShot req.NewScreenshot
		newScreenShot.ProjectID = screenshot.ProjectID
		newScreenShot.ImageURL = screenshot.ImageURL
		message, err := repository.AddScreenshot(ctx, newScreenShot)
		if err != nil {
			return nil, err // Return early if an error occurs
		}
		// message = fmt.Sprintf("%d)", i) + message
		messages = append(messages, message)
		count++
	}
	message := fmt.Sprintf("%d Screenshot Added Successfully", count)
	return &message, nil
}

// DeleteScreenshots is the resolver for the deleteScreenshots field.
func (r *mutationResolver) DeleteScreenshots(ctx context.Context, ids []string, projectID string) (*string, error) {

	// Validate projectID
	if !validate.IsInteger(projectID) {
		return nil, er.WrongIDError
	}

	if len(ids) <= 0 {
		return nil, er.ScreenShotIDsRequiredError
	}

	// Validate each ID in ids
	for _, id := range ids {
		if !validate.IsInteger(id) {
			return nil, er.WrongIDError
		}
	}

	message, err := repository.DeleteScreenshots(ctx, ids, projectID)
	return &message, err
	// return nil, nil
}

// ShareProject is the resolver for the shareProject field.
func (r *mutationResolver) ShareProject(ctx context.Context, input req.NewProjectMember) (*string, error) {
	// panic(fmt.Errorf("not implemented: ShareProject - shareProject"))
	message, err := repository.ShareProject(ctx, input)
	return &message, err
}

// Creator is the resolver for the creator field.
func (r *projectResolver) Creator(ctx context.Context, obj *model.Project) (*model.User, error) {
	// panic(fmt.Errorf("not implemented: Creator - creator"))
	creator, err := dataloaders.CtxLoaders(ctx).UserByID.Load(obj.CreatorID)
	if err != nil {
		return nil, er.InternalServerError
	}
	return creator, nil
}

// ScreenShot is the resolver for the screenShot field.
func (r *projectResolver) ScreenShot(ctx context.Context, obj *model.Project) ([]*model.Screenshot, error) {
	screenshots, err := dataloaders.CtxLoaders(ctx).Screenshots.Load(obj.ID)
	if err != nil {
		return nil, er.InternalServerError
	}
	return screenshots, nil
}

// Projects is the resolver for the projects field.
func (r *queryResolver) Projects(ctx context.Context, limit *int, filter *req.ProjectFilter, sortBy *model.ProjectSort) ([]*model.Project, error) {
	if *limit > 10 {
		return nil, er.UsersProjectsLimitError
	}

	projects, err := repository.Projects(ctx, limit, filter, sortBy)
	return projects, err
}

// Project is the resolver for the project field.
func (r *queryResolver) Project(ctx context.Context, id string) (*model.GetProjectDetail, error) {

	// Validate projectID
	if !validate.IsInteger(id) {
		return nil, er.WrongIDError
	}

	project, err := repository.Project(ctx, id)
	return project, err
}

// ProjectsByUserIDs is the resolver for the projectsByUserIDs field.
func (r *queryResolver) ProjectsByUserIDs(ctx context.Context, ids []string, limit *int, filter *req.ProjectFilter, sortBy *model.ProjectSort) ([]*model.UserProjectDetail, error) {
	if *limit > 5 {
		return nil, er.UsersProjectsLimitError
	}

	if len(ids) == 0 {
		return nil, er.UserIDsRequiredError
	}

	// Validate each ID in ids
	for _, id := range ids {
		if !validate.IsInteger(id) {
			return nil, er.WrongIDError
		}
	}

	projects, err := repository.ProjectsByUserIDs(ctx, ids, limit, filter, sortBy)
	return projects, err
}

// GenerateJwtToken is the resolver for the generateJwtToken field.
func (r *queryResolver) GenerateJwtToken(ctx context.Context, id string, audience string) (*model.AccessToken, error) {
	var accessToken model.AccessToken
	token, err := utils.GenerateJwtToken(id, audience)

	accessToken.Token = token
	return &accessToken, err
}

// GetProjectDetail returns GetProjectDetailResolver implementation.
func (r *Resolver) GetProjectDetail() GetProjectDetailResolver { return &getProjectDetailResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Project returns ProjectResolver implementation.
func (r *Resolver) Project() ProjectResolver { return &projectResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type getProjectDetailResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type projectResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
